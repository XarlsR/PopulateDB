package dev.xarlsr.popdb.userint;

import dev.xarlsr.utilidades.DateUtils;
import dev.xarlsr.utilidades.EntradaTeclado;
import java.util.ArrayList;
import java.util.List;

import static dev.xarlsr.popdb.Parameters.*;

/**
 * Class with the different interface methods to get the needed user inputs.
 */
public class GetData {

    /**
     * List with the type of data fields that can be managed by the app
     */
    public static List<String> typesList;

    /**
     * Name of the table
     */
    public static String tableName;

    /**
     * NUmber of fields that the SQL rows will have
     */
    public static int fieldsCount;

    /**
     * Name of the file to be created and written.
     */
    static String fileName;

    /**
     * Default constructor
     */
    public GetData(){}

    /**
     * Prints by console a helpful list of available field types, got from the
     * list 'typeList' generated by the initTypesList() method.
     */
    public static void printTypesList(){
        for (int i = 0; i<FIELD_TYPES.size();i++) {
            System.out.println(FIELD_TYPES.get(i)+":  "+FIELD_DESC.get(i));
        }
    }

    /**
     * Gets the name of the table from the user and sets to tableName variable.
     * @return String with the name of the table.
     */
    public static String readTableName(){
        EntradaTeclado.borrarPantalla();
        System.out.print("Nombre de la tabla: ");
        return tableName = EntradaTeclado.leeCadena();
    }

    /**
     * Returns the name of the table stored in tableName.
     * @return String with the name of the table.
     */
    public static String getTableName(){
        return tableName;
    }

    /**
     * Sets the number of fields that will build the rows.
     * @return Number of fields stored in fieldsCount integer variable.
     */
    public static int readFieldsCount(){
        //EntradaTeclado.borrarPantalla();
        System.out.print("Número de campos a rellenar: ");
        return fieldsCount=EntradaTeclado.leeEntero();
    }

    /**
     * Returns the number of fields that will build the row.
     * @return Integer number of fields.
     */
    public static int getFieldsCount(){
        return fieldsCount;
    }

    /**
     * Asks the user for the name of field and reads it form console.
     * @return String with the name of the field.
     */
    public static String readFieldName(){
        System.out.print("Nombre del campo: ");
        return EntradaTeclado.leeCadena();
    }

    /**
     * Asks the user for the type of the field to compose. It prints hints via
     * the call to printTypesList() method.
     * @return String with the type entered by user.
     */
    public static String readFieldType(){
        System.out.println("TIPOS DE CAMPOS DISPONIBLES:");
        System.out.println("----------------------------");
        printTypesList();
        System.out.println("----------------------------");
        System.out.print("INTRODUZCA EL TIPO DE CAMPO (puede introducirse en MAY/min indistintamente): ");
        return EntradaTeclado.leeCadena().toUpperCase();
    }

    /**
     * Asks the user for the pathname of the text file to read.
     * @return String with the path entered by user.
     */
    public static String readPathName(){
        System.out.print("Path del fichero del campo: ");
        return EntradaTeclado.leeCadena();
    }

    /**
     * Asks the user to enter a date and returns it to the calling method.
     * @return String with the entered date. The format is "yyyyMMdd".
     */
    public static String readDate() {

        boolean valid;
        String date;

        do {
            System.out.println("Introduzca una fecha en formato AAAAmmDD;");
            date = EntradaTeclado.leeCadena(8);
            // TODO: Resolver el fallo con el método isValidDate, que devuelve error.
            //valid = DateUtils.isValidDate(date);
            valid = true;
            if (valid) {
                return date;
            } else {
                System.out.println("La fecha introducida no es válida");
            }
        }
        while (!valid);
        return date;
    }

    /**
     * Asks the user to enter the number of SQL table filling rows to be generated.
     * Checks if the qty. entered by user is under the maximum. If it fits the parameter
     * MAX_ROWS then proceed. If not, the user is required to enter other qty.
     * @return int Number of data rows to generate.
     */
    public static int readRowsCount() {
        boolean ok = false;
        do {
            System.out.print("Cuantas entradas? (Max "+MAX_ROWS+"): ");
            int rc = EntradaTeclado.leeEntero();
            if (rc > MAX_ROWS){
                System.out.println("El numero de entradas supera el máximo. Indique otra cantidad.");
            }
            else {
                ok = true;
                return rc;
            }
        } while (!ok);
        return 0;
    }

    /**
     * Asks the user for the name of the file and returns it as String.
     * @return String with the name of the file.
     */
    public static String readFileName(){
        System.out.print("Introduzca nombre del fichero SQL:");
        return fileName = EntradaTeclado.leeCadena();
    }

    /**
     * Reads from the user the pattern to generate a random string.
     * @return
     */
    public static String readSPattern() {
        System.out.println("Introduzca el patrón de la cadena a generar.");
        System.out.println("'a' para caracteres, 'n' para números.");
        System.out.println("Cualquier otro carácter quedará como parte del patrón.");
        System.out.print("Patrón a generar: ");
        return EntradaTeclado.leeCadena();
    }
}
